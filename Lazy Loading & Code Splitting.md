სლაიდი 1: სათაური
სათაური: React პროექტის ოპტიმიზაცია

ქვესათაური: Lazy Loading & Code Splitting

ავტორი: (თქვენი სახელი)

ვიზუალი:

სლაიდი 2: პრობლემის აღწერა
სათაური: რატომ ნელდება დიდი React აპლიკაციები?

ტექსტი:

დიდი პროექტები შეიცავს უამრავ კომპონენტს, ბიბლიოთეკას და სხვა კოდს.

პროექტის აგებისას (build), ეს კოდი ერთ დიდ JavaScript ფაილში ერთიანდება, რომელსაც bundle ეწოდება.

აპლიკაციის დატვირთვისას, ბრაუზერმა ჯერ ეს უზარმაზარი bundle უნდა ჩამოტვირთოს, მაშინაც კი, თუ მომხმარებელს მხოლოდ ერთი გვერდი სჭირდება.

ეს ანელებს საწყის დატვირთვას და აუარესებს მომხმარებლის გამოცდილებას.

ვიზუალი:

სლაიდი 3: Lazy Loading და Code Splitting
სათაური: რა არის Lazy Loading და Code Splitting?

ტექსტი:

Code Splitting - არის ტექნიკა, რომლის საშუალებითაც დიდ JavaScript ფაილს ვყოფთ უფრო პატარა, მართვად ნაწილებად.

Lazy Loading - არის კონცეფცია, როდესაც კოდის ეს დაყოფილი ნაწილები იტვირთება მოთხოვნის საფუძველზე (მაგალითად, როდესაც მომხმარებელი კონკრეტულ გვერდზე გადადის).

ვიზუალი:

სლაიდი 4: დიაგრამა: დატვირთვა Lazy Loading-ის გარეშე
სათაური: ერთი დიდი ბანდლი (Lazy Loading-ის გარეშე)

ტექსტი:

აპლიკაციის დასატვირთად, ბრაუზერი ითხოვს მთელ bundle-ს, რომელიც შეიცავს ყველა კომპონენტს.

დიაგრამა:

მომხმარებელი -> ბრაუზერი -> სერვერი

სერვერი აბრუნებს: bundle.js (Home + About + Contact + ...)

ვიზუალი:

სლაიდი 5: დიაგრამა: დატვირთვა Lazy Loading-ით
სათაური: პატარა ბანდლები (Lazy Loading-ით)

ტექსტი:

ბრაუზერი თავდაპირველად ითხოვს მხოლოდ მთავარი გვერდისთვის საჭირო ფაილს.

მხოლოდ მას შემდეგ, რაც მომხმარებელი გადავა სხვა გვერდზე, ჩამოიტვირთება მისთვის საჭირო კოდი.

დიაგრამა:

მომხმარებელი -> ბრაუზერი -> სერვერი

სერვერი აბრუნებს: home.js

მომხმარებელი გადადის About გვერდზე -> ბრაუზერი -> სერვერი

სერვერი აბრუნებს: about.js

ვიზუალი:

სლაიდი 6: React.lazy და Suspense
სათაური: როგორ გამოვიყენოთ Lazy Loading React-ში?

ტექსტი:

React.lazy() არის ფუნქცია, რომელიც კომპონენტს დინამიურად იტვირთება.

Suspense არის React-ის ჩაშენებული კომპონენტი, რომელიც საშუალებას გაძლევთ აჩვენოთ "fallback" (ალტერნატიული) UI მანამ, სანამ მისი შვილები არ დასრულდებიან რენდერირებას. ის ავტომატურად ამუშავებს loading-ის მდგომარეობას, რაც ხელს უშლის ცარიელი ეკრანის გამოჩენას.

კოდის მაგალითი:

import React, { lazy, Suspense } from 'react';

// კომპონენტის იმპორტი lazy-ის გამოყენებით
const AboutPage = lazy(() => import('./pages/AboutPage'));

function App() {
  return (
    <div>
      {/* Suspense აჩვენებს loading-ის მდგომარეობას, სანამ კომპონენტი იტვირთება */}
      <Suspense fallback={<div>გვერდი იტვირთება...</div>}>
        <AboutPage />
      </Suspense>
    </div>
  );
}

სლაიდი 7: პრაქტიკული მაგალითი React Router-თან
სათაური: Lazy Loading React Router-ის გამოყენებით

ტექსტი:

ეს ყველაზე გავრცელებული და ეფექტური მეთოდია, რათა თითოეული გვერდი ცალკე ბანდლად ჩამოიტვირთოს, მხოლოდ მაშინ, როდესაც ის საჭიროა.

კოდის მაგალითი:

import React, { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

const HomePage = lazy(() => import('./pages/HomePage'));
const AboutPage = lazy(() => import('./pages/AboutPage'));
const ContactPage = lazy(() => import('./pages/ContactPage'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>გვერდი იტვირთება...</div>}>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/about" element={<AboutPage />} />
          <Route path="/contact" element={<ContactPage />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

სლაიდი 8: დამატებითი ოპტიმიზაციის ტექნიკები
სათაური: სხვა მნიშვნელოვანი ტექნიკები

ტექსტი:

Dynamic Imports (import()): JavaScript-ის ფუნქცია, რომელიც საშუალებას იძლევა, მოდულები დინამიურად ჩავტვირთოთ. სწორედ ამას ეფუძნება React.lazy().

Tree Shaking: პროცესი, რომელიც აშორებს გამოუყენებელ კოდს საბოლოო ფაილიდან.

Minification: კოდის შეკუმშვა (მაგალითად, ცვლადების სახელების დამოკლება, ცარიელი ადგილების წაშლა), რაც ფაილის ზომას ამცირებს.

ვიზუალი:

სლაიდი 9: დასკვნა
სათაური: შეჯამება

ტექსტი:

Lazy Loading და Code Splitting აუცილებელია სწრაფი და ეფექტური React აპლიკაციების შესაქმნელად.

ისინი ამცირებენ საწყისი დატვირთვის დროს და აუმჯობესებენ მომხმარებლის გამოცდილებას.

ეს ტექნიკები საშუალებას გვაძლევს, მივაწოდოთ მომხმარებელს მხოლოდ ის კოდი, რაც მას კონკრეტულ მომენტში სჭირდება.

ვიზუალი:
